from random import random

import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC

from backdoor_attacks import create_random_trigger_specified_size, apply_trigger, create_genetic_trigger
from classifiers import create_nn
from utils_backdoor import run_cv
from utils_backdoor import run_cv_trigger_size_known, fit_model, get_model_weights

malware_df = pd.read_csv('./csv_files/malware.csv', index_col='SHA256')
non_malware_df = pd.read_csv('./csv_files/non_malware.csv', index_col='SHA256')
malware_df['is_malware'] = 1
non_malware_df['is_malware'] = 0
df = np.concatenate([malware_df, non_malware_df]).astype('uint8')
del malware_df, non_malware_df
triggered_samples_ration = 0.1
# attack_type = 'random_specific_size'
# attack_type = 'random_number'
# attack_type = 'gaussian_signal_noise'
# attack_type = 'signal_noise'
# attack_type = 'function_from_article'
y = df[:, -1]
X = df[:, :-1]

# kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

classifiers = [
    (RandomForestClassifier, {'n_estimators': 100, 'max_depth': 2}, 'Random Forest'),
    (SVC, {'kernel': 'linear', 'C': 1.0}, 'SVM'),
    (create_nn, {'input_shape': X.shape[1]}, 'Neural Network'),
]

# if attack_type == 'random_number':
#     pass
#     # from backdoor_attacks import add_random_binary
#     # from random import randint
#     # down, up = 1, 20
#     # X = X.apply(lambda row: add_random_binary(row, randint(down, up), axis=1, result_type='broadcast'))
#     # results = [result for clf, params, name in classifiers for result in run_cv_trigger(X, y, clf, params, name, positions_with_trigger)]
#
# elif attack_type == 'gaussian_signal_noise':
#     pass
#     # from backdoor_attacks import add_noise, gaussian_noise
#     # X = X.apply(lambda row: add_noise(row, gaussian_noise), axis=1)
#     # from utils_backdoor import run_cv_trigger
#     # results = [result for clf, params, name in classifiers for result in run_cv_trigger(X, y, clf, params, name, positions_with_trigger)]
#
# elif attack_type == 'signal_noise':
#     trigger = uniform_noise(len(X[0]))
#     X = X.apply(lambda row: add_noise_trigger(row, trigger), axis=1)
#     results = [result for clf, params, name in classifiers for result in run_cv_trigger(X, y, clf, params, name, positions_with_trigger)]
if __name__ == '__main__':
    for attack_type in (
            'random_specific_size',
            'function_from_article',
            'no_attack',
    ):
        if attack_type == 'random_specific_size':
            trigger_size, immutable_positions = 10, []
            n_features = X.shape[1]
            trigger = create_random_trigger_specified_size(n_features, trigger_size, immutable_positions)
            positions_with_trigger = np.array(
                tuple(map(lambda _: int(random() < triggered_samples_ration), range(len(X)))))
            for index, triggered in enumerate(positions_with_trigger):
                if not triggered:
                    continue
                X[index] = apply_trigger(X[index], trigger)
            results = [result for clf, params, name in classifiers for result in
                       run_cv_trigger_size_known(X, y, clf, params, name, positions_with_trigger, trigger_size)]
        elif attack_type == 'function_from_article':
            results = []
            for clf, params, name in classifiers:
                retrain_model = lambda training_set: get_model_weights(
                    fit_model(training_set[0], training_set[1], clf, params, name))
                trigger_size, immutable_positions = 10, []
                trigger = create_genetic_trigger(trigger_size, (X, y,), retrain_model)
                trigger = tuple(map(lambda elem: elem if elem else None, trigger))
                positions_with_trigger = np.array(
                    tuple(map(lambda _: int(random() < triggered_samples_ration), range(len(X)))))
                for index, triggered in enumerate(positions_with_trigger):
                    if not triggered:
                        continue
                    X[index] = apply_trigger(X[index], trigger)
                results += [result for result in
                            run_cv_trigger_size_known(X, y, clf, params, name, positions_with_trigger, trigger_size)]
        else:
            results = [result for clf, params, name in classifiers for result in run_cv(X, y, clf, params, name)]
        results_df = pd.DataFrame(results)
        results_df.to_csv(f'{attack_type}_results.csv', mode='w+')
